<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>手書きメモ - 複数選択移動対応</title>
<style>
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif; }
    
    .toolbar { 
        position: fixed; top: 10px; left: 50%; transform: translateX(-50%); 
        display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; align-items: center; 
        background: rgba(255, 255, 255, 0.95); padding: 8px 12px; border-radius: 25px; 
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); z-index: 100; width: 90%; max-width: 700px; 
    }

    canvas { display: block; background-color: white; touch-action: none; }

    .btn { 
        padding: 6px 10px; cursor: pointer; border: 1px solid #ccc; border-radius: 15px; 
        background-color: white; font-size: 12px; outline: none; white-space: nowrap; 
    }

    .btn.active { background-color: #007bff; color: white; border-color: #007bff; }
    
    #textInputOverlay { position: fixed; display: none; border: 1px dashed #007bff; background: transparent; outline: none; z-index: 200; }
    
    input[type="color"] { border: none; width: 22px; height: 22px; cursor: pointer; background: none; }
    input[type="range"] { width: 60px; } 

    .save-btn { background-color: #28a745; color: white; border: none; }
    #imageInput { display: none; }
</style>
</head>
<body>

    <div class="toolbar">
        <button class="btn active" id="penBtn">ペン</button>
        <button class="btn" id="eraserBtn">消しゴム</button>
        <button class="btn" id="textBtn">文字</button>
        <button class="btn" id="imageBtn">画像</button>
        <button class="btn" id="moveBtn">選択・移動</button>
        <input type="color" id="colorPicker" value="#000000">
        <input type="range" id="lineWidth" min="1" max="30" value="5">
        <button class="btn" id="clearBtn" style="background-color: #ff4d4d; color: white; border: none;">全消去</button>
        <button class="btn save-btn" id="downloadBtn">保存</button>
    </div>

    <input type="file" id="imageInput" accept="image/*">
    <input type="text" id="textInputOverlay">
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const textInputOverlay = document.getElementById('textInputOverlay');
        const imageInput = document.getElementById('imageInput');
        const buttons = document.querySelectorAll('.btn');

        let mode = 'pen';
        let objects = []; 
        let selectedObjects = []; // 複数選択用
        let isDragging = false;
        let isResizing = false;
        let isSelectingArea = false; // 範囲選択中か
        let selectionRect = { x: 0, y: 0, w: 0, h: 0 }; // 選択枠の座標
        let startX, startY;
        const HANDLE_SIZE = 10;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redraw();
        }
        window.onresize = resizeCanvas;
        resizeCanvas();

        function setMode(newMode, btn) {
            mode = newMode;
            buttons.forEach(b => b.classList.remove('active'));
            if(btn) btn.classList.add('active');
            selectedObjects = []; // モード切替時に選択解除
            redraw();
        }

        document.getElementById('penBtn').onclick = (e) => setMode('pen', e.target);
        document.getElementById('eraserBtn').onclick = (e) => setMode('eraser', e.target);
        document.getElementById('textBtn').onclick = (e) => setMode('text', e.target);
        document.getElementById('moveBtn').onclick = (e) => setMode('move', e.target);
        document.getElementById('imageBtn').onclick = () => imageInput.click();

        function addImageObject(img, x, y) {
            const scale = Math.min((canvas.width * 0.3) / img.width, (canvas.height * 0.3) / img.height, 1);
            const w = img.width * scale;
            const h = img.height * scale;
            const obj = { type: 'image', img: img, x, y, w, h };
            objects.push(obj);
            updateBounds(obj);
            redraw();
            setMode('move', document.getElementById('moveBtn'));
            selectedObjects = [obj];
        }

        imageInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => addImageObject(img, 50, 100);
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        };

        window.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (const item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const img = new Image();
                        img.onload = () => addImageObject(img, window.innerWidth/2 - 50, window.innerHeight/2 - 50);
                        img.src = ev.target.result;
                    };
                    reader.readAsDataURL(blob);
                }
            }
        });

        function redraw(isExport = false) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            objects.forEach(obj => {
                ctx.beginPath();
                ctx.strokeStyle = obj.color || "#000";
                ctx.fillStyle = obj.color || "#000";
                ctx.lineWidth = obj.width || 1;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                if (obj.type === 'pen') {
                    obj.points.forEach((p, i) => {
                        if (i === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    });
                    ctx.stroke();
                } else if (obj.type === 'text') {
                    ctx.font = `${obj.width + 15}px sans-serif`;
                    ctx.fillText(obj.text, obj.x, obj.y);
                } else if (obj.type === 'image') {
                    ctx.drawImage(obj.img, obj.x, obj.y, obj.w, obj.h);
                }

                // 選択中のハイライト表示
                if (!isExport && mode === 'move' && selectedObjects.includes(obj)) {
                    ctx.strokeStyle = '#007bff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(obj.bounds.x - 2, obj.bounds.y - 2, obj.bounds.w + 4, obj.bounds.h + 4);
                    ctx.setLineDash([]);
                    
                    // 単一選択の画像のみリサイズハンドルを表示
                    if (obj.type === 'image' && selectedObjects.length === 1) {
                        ctx.fillStyle = '#007bff';
                        ctx.fillRect(obj.x + obj.w - HANDLE_SIZE/2, obj.y + obj.h - HANDLE_SIZE/2, HANDLE_SIZE, HANDLE_SIZE);
                    }
                }
            });

            // 範囲選択枠の描画
            if (isSelectingArea && !isExport) {
                ctx.strokeStyle = 'rgba(0, 123, 255, 0.5)';
                ctx.fillStyle = 'rgba(0, 123, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.fillRect(selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h);
                ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h);
            }
        }

        function getMousePos(e) {
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);
            return { x, y };
        }

        function isHit(obj, pos) {
            if (!obj.bounds) return false;
            return pos.x >= obj.bounds.x && pos.x <= obj.bounds.x + obj.bounds.w &&
                   pos.y >= obj.bounds.y && pos.y <= obj.bounds.y + obj.bounds.h;
        }

        function isHandleHit(obj, pos) {
            if (obj.type !== 'image') return false;
            return pos.x >= obj.x + obj.w - HANDLE_SIZE && pos.x <= obj.x + obj.w + HANDLE_SIZE &&
                   pos.y >= obj.y + obj.h - HANDLE_SIZE && pos.y <= obj.y + obj.h + HANDLE_SIZE;
        }

        canvas.onmousedown = canvas.ontouchstart = (e) => {
            if (e.type === 'touchstart' && e.touches.length > 1) return; // マルチタッチ無視
            if (e.type === 'touchstart') e.preventDefault();
            const pos = getMousePos(e);
            startX = pos.x; startY = pos.y;

            if (mode === 'pen') {
                isDragging = true;
                currentObject = { type: 'pen', color: document.getElementById('colorPicker').value, width: parseInt(document.getElementById('lineWidth').value), points: [{x: pos.x, y: pos.y}] };
                objects.push(currentObject);
            } else if (mode === 'eraser') {
                isDragging = true;
                eraseAt(pos);
            } else if (mode === 'text') {
                showTextInput(pos.x, pos.y);
            } else if (mode === 'move') {
                // 1. リサイズハンドルの判定
                if (selectedObjects.length === 1 && isHandleHit(selectedObjects[0], pos)) {
                    isResizing = true;
                } else {
                    // 2. オブジェクトを直接クリックしたか判定
                    const hit = [...objects].reverse().find(obj => isHit(obj, pos));
                    if (hit) {
                        if (!selectedObjects.includes(hit)) {
                            selectedObjects = [hit]; // 未選択なら単一選択に切替
                        }
                        isDragging = true;
                    } else {
                        // 3. 何もない場所なら範囲選択を開始
                        selectedObjects = [];
                        isSelectingArea = true;
                        selectionRect = { x: pos.x, y: pos.y, w: 0, h: 0 };
                    }
                }
                redraw();
            }
        };

        window.onmousemove = window.ontouchmove = (e) => {
            const pos = getMousePos(e);

            if (isSelectingArea) {
                selectionRect.w = pos.x - selectionRect.x;
                selectionRect.h = pos.y - selectionRect.y;
                redraw();
            } else if (isResizing && selectedObjects.length === 1) {
                const obj = selectedObjects[0];
                obj.w = Math.max(20, pos.x - obj.x);
                obj.h = Math.max(20, pos.y - obj.y);
                updateBounds(obj);
                redraw();
            } else if (isDragging) {
                if (mode === 'pen') {
                    currentObject.points.push({x: pos.x, y: pos.y});
                } else if (mode === 'eraser') {
                    eraseAt(pos);
                } else if (mode === 'move') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    selectedObjects.forEach(obj => {
                        if (obj.type === 'pen') {
                            obj.points.forEach(p => { p.x += dx; p.y += dy; });
                        } else {
                            obj.x += dx; obj.y += dy;
                        }
                        updateBounds(obj);
                    });
                    startX = pos.x; startY = pos.y;
                }
                redraw();
            }
        };

        window.onmouseup = window.ontouchend = () => {
            if (isSelectingArea) {
                // 選択範囲内のオブジェクトを特定
                const x1 = Math.min(selectionRect.x, selectionRect.x + selectionRect.w);
                const x2 = Math.max(selectionRect.x, selectionRect.x + selectionRect.w);
                const y1 = Math.min(selectionRect.y, selectionRect.y + selectionRect.h);
                const y2 = Math.max(selectionRect.y, selectionRect.y + selectionRect.h);

                selectedObjects = objects.filter(obj => {
                    return obj.bounds.x >= x1 && obj.bounds.x + obj.bounds.w <= x2 &&
                           obj.bounds.y >= y1 && obj.bounds.y + obj.bounds.h <= y2;
                });
            }
            isDragging = false;
            isResizing = false;
            isSelectingArea = false;
            currentObject = null;
            redraw();
        };

        function eraseAt(pos) {
            const targetIndex = objects.findIndex(obj => isHit(obj, pos));
            if (targetIndex !== -1) {
                objects.splice(targetIndex, 1);
                redraw();
            }
        }

        function updateBounds(obj) {
            if (obj.type === 'pen') {
                const xs = obj.points.map(p => p.x);
                const ys = obj.points.map(p => p.y);
                obj.bounds = { x: Math.min(...xs), y: Math.min(...ys), w: Math.max(...xs) - Math.min(...xs), h: Math.max(...ys) - Math.min(...ys) };
            } else if (obj.type === 'text') {
                const fontSize = obj.width + 15;
                ctx.font = `${fontSize}px sans-serif`;
                const metrics = ctx.measureText(obj.text);
                obj.bounds = { x: obj.x, y: obj.y - fontSize, w: metrics.width, h: fontSize };
            } else if (obj.type === 'image') {
                obj.bounds = { x: obj.x, y: obj.y, w: obj.w, h: obj.h };
            }
        }

        function showTextInput(x, y) {
            textInputOverlay.style.display = 'block';
            textInputOverlay.style.left = x + 'px';
            textInputOverlay.style.top = (y - 15) + 'px';
            textInputOverlay.style.fontSize = (parseInt(document.getElementById('lineWidth').value) + 15) + 'px';
            textInputOverlay.value = '';
            setTimeout(() => textInputOverlay.focus(), 10);
            textInputOverlay.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    const obj = { type: 'text', x, y, text: textInputOverlay.value, color: document.getElementById('colorPicker').value, width: parseInt(document.getElementById('lineWidth').value) };
                    objects.push(obj);
                    updateBounds(obj);
                    textInputOverlay.style.display = 'none';
                    redraw();
                }
            };
        }

        document.getElementById('clearBtn').onclick = () => { if(confirm('全消去しますか？')) { objects = []; selectedObjects = []; redraw(); } };

        document.getElementById('downloadBtn').onclick = () => {
            redraw(true); 
            const image = canvas.toDataURL("image/png");
            const now = new Date();
            const fileName = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}.png`;
            const link = document.createElement('a');
            link.download = fileName; link.href = image; link.click();
            redraw(false);
        };
    </script>
</body>
</html>
